#!/usr/bin/env python
from __future__ import print_function
import numpy
from argparse import ArgumentParser
import reredux

parser = ArgumentParser()

parser.add_argument('run', help='run to use in fit')
parser.add_argument('refrun',help='run used for correction')

parser.add_argument('--show',action='store_true',help='show plot')
parser.add_argument('--yrange', help="yrange of plot")

parser.add_argument('--boot',action='store_true',help='bootstrap fits')
parser.add_argument('--nboot',type=int,
                    default=100,help='number of bootstraps')

def doplot(data, fits, args):
    import biggles

    if args.yrange is not None:
        yrange=[float(r) for r in args.yrange.split(',')]
    else:
        yrange=[-0.01,0.01]

    tab=biggles.Table(1,2)
    tab.aspect_ratio=0.5

    diff = data['shear'] - data['shear_true']

    plts=[]
    for i in [0,1]:

        x = data['shear_true'][:,i]
        plt =biggles.plot(x,
                          diff[:,i],
                          #yerr=data['shear_err'][:,i],
                          xlabel='shear%d true' % (i+1,),
                          ylabel='shear%d diff' % (i+1,),
                          yrange=yrange,
                          visible=False)
        yfit=fits['m'][i]*x + fits['c'][i]

        c=biggles.Curve(x, yfit, color='red')
        z=biggles.Curve(x, x*0, color='black')
        plt.add(c,z)

        tab[0,i] = plt

    tab.show(width=1000, height=1000)

def read_data(conf, run):

    model=conf['model_pars'].keys()[0]

    columns=['%s_mcal_g' % model,
             '%s_mcal_gpsf' % model,
             'shear_index',
             'flags']
    data=reredux.files.read_collated(run, columns=columns)

    w,=numpy.where(data['flags']==0)
    data=data[w]

    return data


def read_refdata(conf, run):

    model=conf['model_pars'].keys()[0]

    columns=['%s_mcal_R' % model,
             '%s_mcal_Rpsf' % model,
             'flags']

    data=reredux.files.read_collated(run, columns=columns)

    w,=numpy.where(data['flags']==0)
    data=data[w]

    return data


def get_mean_struct(n):
    dt=[('shear','f8',2),
        ('shear_true','f8',2),
        ('shear_err','f8',2)]

    means = numpy.zeros(n, dtype=dt)
    return means

def print_shear(ind, num, shear, shear_err):
    mess="  %d: %d  %g +/- %g  %g +/- %g"
    tup=(ind, num, shear[0],shear_err[0], shear[1],shear_err[1])
    print(mess % tup)



def get_averages(conf, data, refdata):

    sconf=conf['sconf']
    shears = sconf['shear']['shears']

    model=conf['model_pars'].keys()[0]

    gfield = '%s_mcal_g' % model
    gpsf_field = '%s_mcal_gpsf' % model
    Rfield = '%s_mcal_R' % model
    Rpsf_field = '%s_mcal_Rpsf' % model

    g = data[gfield]
    gpsf = data[gpsf_field]

    R = refdata[Rfield].mean(axis=0)
    Rinv = numpy.linalg.inv(R)
    Rpsf = refdata[Rpsf_field].mean(axis=0)

    uind = numpy.unique(data['shear_index'])
    nind = uind.size

    means=get_mean_struct(nind)

    for i,ind in enumerate(uind):

        shear_true = shears[ind]

        w,=numpy.where(data['shear_index'] == ind)

        psf_corr  = gpsf[w].mean(axis=0)*Rpsf
        gmean     = g[w].mean(axis=0)
        shear     = numpy.dot(Rinv, gmean-psf_corr)
        shear_err = g[w].std(axis=0)/numpy.sqrt(w.size)
        shear_err = numpy.dot(Rinv, shear_err)

        means['shear'][i] = shear
        means['shear_err'][i] = shear_err
        means['shear_true'][i] = shear_true

        if False and (i % 10) == 0:
            print_shear(ind, w.size, shear, shear_err)

    return means

def print_m_c(sindex, m, merr, c, cerr):
    fmt = '  s%d m: %.3e +/- %.3e c: %.3e +/- %.3e'
    print(fmt % (sindex,m, merr, c, cerr))

def fit_m_c(data):
    import fitting
    import mcmc
    import esutil as eu

    strue = data['shear_true']
    sdiff = data['shear'] - data['shear_true']
    serr = data['shear_err']

    m = numpy.zeros(2)
    merr = numpy.zeros(2)
    c = numpy.zeros(2)
    cerr = numpy.zeros(2)

    fits=[]
    for i in [0,1]:
        w,=numpy.where(strue[:,i] != 0.0)
        if w.size == 0:
            print("shear is zero, mean for all is")
            m,e=eu.stat.wmom(data['shear'][:,i],
                             1.0/data['shear_err'][:,i]**2,
                             calc_err=True)
            print("s%d: %.3e +/- %.3e" % (i+1,m,e))
        else:
            fit = fitting.fit_line(strue[:,i],
                                   sdiff[:,i],
                                   yerr=serr[:,i])
            res = fit.get_result()
            p=res['pars']
            perr=res['perr']

            print_m_c(i+1, p[0],perr[0],p[1],perr[1])

            m[i] = p[0]
            merr[i] = perr[0]
            c[i] = p[1]
            cerr[i] = perr[1]

    return {'m':m,
            'merr':merr,
            'c':c,
            'cerr':cerr}

def fit_m_c_boot(fits, conf, data, refdata, nboot):

    nd=data.size
    nr=refdata.size

    mvals = numpy.zeros( (nboot,2) )
    cvals = numpy.zeros( (nboot,2) )

    for i in xrange(nboot):
        print("bootstrap: %d/%d" % (i+1,nboot))

        rind     = numpy.random.randint(0, nd, nd)
        rind_ref = numpy.random.randint(0, nr, nr)

        means = get_averages(conf, data[rind], refdata[rind_ref])
        tfits=fit_m_c(means)

        mvals[i] = tfits['m']
        cvals[i] = tfits['c']

    mmean = mvals.mean(axis=0)
    cmean = cvals.mean(axis=0)
    merr = mvals.std(axis=0)
    cerr = cvals.std(axis=0)

    print("bootstrapped")
    for i in [0,1]:
        print_m_c(i+1, fits['m'][i], merr[i], fits['c'][i], cerr[i])

def main():
    args = parser.parse_args()

    conf=reredux.files.read_config(args.run)
    sconf=reredux.files.read_egret_config(conf['reredux_config'])

    conf['sconf'] = sconf

    data=read_data(conf, args.run)
    refdata=read_refdata(conf, args.refrun)

    means = get_averages(conf, data, refdata)
    fits=fit_m_c(means)

    if args.boot:
        boot_fits = fit_m_c_boot(fits, conf, data, refdata, args.nboot)


    if args.show:
        doplot(means, fits, args)

main()
